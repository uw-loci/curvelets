function [measAngs,measDist,inCurvsFlag,outCurvsFlag,measBndry,numImPts,insCt] = getTifBoundary(coords,img,object,imgName,distThresh,fibKey,endLength,fibProcMeth)

% getTifBoundary.m - This function takes the coordinates from the boundary file, associates them with curvelets, and produces relative angle measures. 
% 
% Inputs:
%   coords - the locations of the endpoints of each line segment making up the boundary
%   img - the image being measured
%   object - a struct containing the center and angle of each measured curvelet, generated by the newCurv function
%   distThresh - number of pixels from boundary we should evaluate curvelets
%   boundaryImg - tif file with boundary outlines, must be a mask file
%   fibKey - list indicating the beginning of each new fiber in the object struct, allows for fiber level processing
%
% Output:
%   measAngs - all relative angle measurements, not filtered by distance
%   measDist - all distances between the curvelets and the boundary points, not filtered
%   inCurvsFlag - curvelets that are considered
%   outCurvsFlag - curvelets that are not considered
%   measBndry = points on the boundary that are associated with each curvelet
%   inDist = distance between boundary and curvelet for each curvelet considered
%   numImPts = number of points in the image that are less than distThresh from boundary
%   insCt = number of curvelets inside an epithelial region
%
%
% By Jeremy Bredfeldt, LOCI, Morgridge Institute for Research, 2013


%Note: a "curv" could be a curvelet or a fiber segment, depending on if CT or FIRE is used

imHeight = size(img,1);
imWidth = size(img,2);


% figure(3);
% hold all;
% for k = 1:length(coords)
%    boundary = coords{k};
%    plot(boundary(:,2), boundary(:,1), 'y', 'LineWidth', 2);
%    drawnow;
% end


allCenterPoints = vertcat(object.center);
coords = vertcat(coords{:,1});
[idx_dist,dist] = knnsearch(coords,allCenterPoints);

%Make a list of points in the image (points scattered throughout the image)
% C = floor(imWidth/20); %use at least 20 per row in the image, this is done to speed this process up
% [I, J] = ind2sub(size(img),1:C:imHeight*imWidth);
% allImPoints = [I; J]';
% %Get list of image points that are a certain distance from the boundary
% [~,dist_im] = knnsearch(coords(1:3:end,:),allImPoints); %returns nearest dist to each point in image
% %threshold distance
% inIm = dist_im <= distThresh;
% %count number of points
% inPts = allImPoints(inIm);
% numImPts = length(inPts)*C;
numImPts = 0;


%process all curvs, at this point 
curvsLen = length(object);
measAngs = nan(1,curvsLen);
measDist = nan(1,curvsLen);
measBndry = nan(curvsLen,2);

% h = figure(100); clf;
% imagesc(img);
% colormap('Gray');
% hold on;

inCurvsFlag = ~logical(1:curvsLen);
outCurvsFlag = ~logical(1:curvsLen);
insCt = 0; %count number of fibers inside epithelial regions



for i = 1:curvsLen
%for i = 1:5
    disp(['Processing fiber ' num2str(i) ' of ' num2str(curvsLen) '.']);
    
    %Count the number within epithelial region
    
    if img(object(i).center(1),object(i).center(2)) ~= 0
        insCt = insCt + 1;
    end       
    
    %--Make Association between fiber and boundary and get boundary angle here--
    %Get all points along the curvelet and orthogonal curvelet
    
    [lineCurv orthoCurv] = getPointsOnLine(object(i),imWidth,imHeight,distThresh);
%     plot(lineCurv(:,1),lineCurv(:,2),'b');
%     plot(object(i).center(1,2),object(i).center(1,1),'g.','MarkerSize',12); % show curvelet center 
%     drawnow;
    %Get the intersection between the curvelet line and boundary    
    [intLine, iLa, iLb] = intersect([lineCurv(:,2) lineCurv(:,1)],coords,'rows');
    
    if (~isempty(intLine))
        %get the closest distance from the curvelet center to the
        %intersection (get rid of the farther one(s)) 
        [idxLineDist, lineDist] = knnsearch(intLine,object(i).center);
        inCurvsFlag(i) = 1;
        boundaryPtIdx = iLb(idxLineDist);
        boundaryDist = lineDist;
        class = 1;
    else    
        %use closest point, if that's close enough            
        if dist(i) <= distThresh                
            inCurvsFlag(i) = 1;
            boundaryPtIdx = idx_dist(i);
            boundaryDist = dist(i);
            class = 2;
        else
            %if closest dist isn't enough, throw out
            outCurvsFlag(i) = 1;
            boundaryPtIdx = idx_dist(i);
            boundaryDist = dist(i);
            class = 3;
        end
    end
    
    
    
    boundaryAngle = FindOutlineSlope([coords(:,2),coords(:,1)],boundaryPtIdx);
    boundaryPt = coords(boundaryPtIdx,:);
    

%     %plot the center point
%     plot([object(i).center(1,2) boundaryPt(1,2)],[object(i).center(1,1) boundaryPt(1,1)]);

%     plot(object(i).center(2),object(i).center(1),'y*');
%     %plot boundary point and association line
%     if class == 1       
%         plot(boundaryPt(2),boundaryPt(1),'go');
%         plot([object(i).center(2) boundaryPt(2)],[object(i).center(1) boundaryPt(1)],'g');
%     elseif class == 2        
%         plot(boundaryPt(2),boundaryPt(1),'bo');
%         plot([object(i).center(2) boundaryPt(2)],[object(i).center(1) boundaryPt(1)],'b');
%     else        
%         plot(boundaryPt(2),boundaryPt(1),'ro');
%         plot([object(i).center(2) boundaryPt(2)],[object(i).center(1) boundaryPt(1)],'r');
%     end        
%     drawnow; %pause(0.001);
    
    if (boundaryPt(1) == 1 || boundaryPt(2) == 1 || boundaryPt(1) == imHeight || boundaryPt(2) == imWidth)
        %don't count fiber if boundary point is along edge of image
        tempAng = 0;
    else
        %--compute relative angle here--
        fibAng = object(i).angle;  
        %There is a 90 degree phase shift in fibAng and boundaryAngle due to image orientation issues in Matlab.
        % -therefore no need to invert (ie. 1-X) circ_r here.
        tempAng = circ_r([fibAng*2*pi/180; boundaryAngle*2*pi/180]);
        tempAng = 180*asin(tempAng)/pi;
    end
    
    %--store result here--
    measAngs(i) = tempAng;
    measDist(i) = boundaryDist;
    measBndry(i,:) = boundaryPt;    
end

measAngs = measAngs';
measDist = measDist';

end %of main function

     
function [lineCurv orthoCurv] = getPointsOnLine(object,imWidth,imHeight,boxSz)
    center = object.center;
    angle = object.angle;
    slope = -tand(angle);
    %orthoSlope = -tand(angle + 90); %changed from tand(obj.ang) to -tand(obj.ang + 90) 10/12 JB
    intercept = center(1) - (slope)*center(2);
    %orthoIntercept = center(1) - (orthoSlope)*center(2);
    
    %[p1 p2] = getBoxInt(slope, intercept, imWidth, imHeight, center, boxSz);
    if isinf(slope)
        dist_y = 0;
        dist_x = boxSz;
    else
        dist_y = boxSz/sqrt(1+slope*slope);
        dist_x = dist_y*slope;
    end
    p1 = [center(2) - dist_y, center(1) - dist_x];
    p2 = [center(2) + dist_y, center(1) + dist_x];
    [lineCurv ~] = GetSegPixels(p1,p2);
    
    %Not using the orthogonal slope for anything now
    %[p1 p2] = getIntImgEdge(orthoSlope, orthoIntercept, imWidth, imHeight, center);
    %[orthoCurv, ~] = GetSegPixels(p1,p2);
    orthoCurv = [];
    
end
