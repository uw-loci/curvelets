function [relativeAngles, ROImeasurements ] = getRelativeangles(ROI,object,angleOption,figFlag)
% getRelativeangles.m - This function takes the coordinates from the
% boundary file and fiber location and orientation, and produces
% relative angle measures, including the angle between fiber and the line
% linking the boundary center and the fiber center and the angle between
% the fiber and the orientation of the boundary
% Inputs:
% ROI-a structure containing:
%    coords - the locations of the endpoints of each line segment making up the boundary
%    imageWidth- asssociated image width
%    imageHeight-associated image height
%    imagePath-path to the associated image
%    index2object- index of the boundary segement that associated with the
%    object to be measured
% object-a structure containing:
%    center: the center postion
%    angle: angle of each measured curvelet/fiber, generated by the newCurv/ctFIRE function
% angleOption:
%    1: calculate fiber angle with respect to the boundary edge
%    2: calculate fiber angle with respect to the boundary center or boundary orientation
%    3: calculate fiber angle with repect the the line linking  fiber center and boundary center
%    0: calculate all 1,2,3
% figFlag: show the angles if figFlag =1 and angleOption = 0 
% Output:
%   relativeAngles - all relative angle measurements, [angle2boundaryEdge
%   angle2boundaryCenter angle2centersLine]
%
%   ROImeasurements - propertes of the ROI:center,orientation, area,
%   boundary
% example:
% ROI.coords = [100 100; 120 120; 140 130; 130 100;120 90];
% ROI.imageWidth = 512;
% ROI.imageHeight = 512;
% ROI.index2object  = 3;
% ROI.associatedPoint = ROI.coords(:,1);
% object.center = [135 90];
% object.angle = 60;
% angleOption = 0;
% [relativeAngles, ROImeasurements ] = getRelativeangles(ROI,object,angleOption);
%By Laboratory for Optical and Computational Instrumentation, UW-Madison
%since 2009

% initialize the output variables
relativeAngles = struct('angle2boundaryEdge',[],'angle2boundaryCenter',[],'angle2centersLine',[]);
ROImeasurements = struct('center',[],'orientation',[],'area',[],'boundary',[]);
figureFlag = 0;  % do not show angles
% receive input
coords = ROI.coords; % [y x]
imHeight = ROI.imageHeight;
imWidth = ROI.imageWidth;
fibAng = object.angle;
objectCenter = fliplr(object.center);  %[x y];
objectAngle = object.angle;
centersLineAngle =[];
angleNames = {
    'fiber relative angle with respect to the boundary edge [0-90 degrees]',...
    'fiber relative angle with respect to ROI orientation [0-90 degrees]',...
    'fiber relative angle with respect to the line connecting fiber and ROI centers[0-90 degrees]'};

% calculate the boundary properties
imageI = zeros(ROI.imageHeight,ROI.imageWidth);
roiMask = roipoly(imageI,ROI.coords(:,2),ROI.coords(:,1));
roiProps = regionprops(roiMask,'all');
if length(roiProps) == 1
    ROImeasurements.center = roiProps.Centroid; % [x y]
    ROImeasurements.orientation = roiProps.Orientation;
    % convert to [0 180]degrees
    if ROImeasurements.orientation < 0
        ROImeasurements.orientation = 180+ROImeasurements.orientation;
    end
    ROImeasurements.area = roiProps.Area;
    ROImeasurements.boundary = coords;
else
   error('The coordinates should be from a signle region of interest')
end
boundaryCenter = ROImeasurements.center; %[x y]
roiAngle = ROImeasurements.orientation;
if nargin ==2
    % fprintf('Caculate all 3 relative angles: \n 1) %s \n 2) \s \n 3) %s \n',...
    %     angleNames{1}, angleNames{2},angleNames{3})
    methodAngle = 0;  % by default, calculate all angles
elseif nargin == 3
    % if angleOption ~= 0
    %     fprintf('Calculate %s \n',angleNames{angleOption})
    % else
    %     fprintf('Caculate all 3 relative angles: \n 1) %s \n 2) %s \n 3) %s \n',...
    %         angleNames{1}, angleNames{2},angleNames{3})
    % end
    methodAngle = angleOption;
elseif nargin == 4
    if isempty(angleOption)
        methodAngle = 0;
    else
        % if angleOption ~= 0
        %     fprintf('Calculate %s \n',angleNames{angleOption})
        % else
        %     fprintf('Caculate all 3 relative angles: \n 1) %s \n 2) %s \n 3) %s \n',...
        %         angleNames{1}, angleNames{2},angleNames{3})
        % end
        methodAngle = angleOption;
    end
    figureFlag = figFlag;
elseif nargin > 4 ||nargin < 2
    error('Number of input arguments should be 2, 3, or 4')
end

if methodAngle == 1
    getRelativeangle1
elseif methodAngle == 2  % fiber relative angle with respect to ROI orientation'
    getRelativeangle2
elseif methodAngle == 3 % fiber relative angle with respect to the line connecting fiber and ROI centers
    getRelativeangle3
elseif methodAngle == 0
    getRelativeangle1
    getRelativeangle2
    getRelativeangle3
    if figureFlag == 1
        showAngles
    end
else
    error (sprintf('Index for relative angle calculation should be 0, 1, 2, or 3 '))
end

    function getRelativeangle1
        idx = ROI.index2object;
        boundaryPt = coords(ROI.index2object,:);
        ROI.associatedPoint = boundaryPt;
        boundaryAngle = FindOutlineSlope([coords(:,1),coords(:,2)],idx);
        if (boundaryPt(1) == 1 || boundaryPt(2) == 1 || boundaryPt(1) == imHeight || boundaryPt(2) == imWidth)
            %don't count fiber if boundary point is along edge of image
            tempAng = 0;
        else
            %--compute relative angle here--
            %There is a 90 degree phase shift in fibAng and boundaryAngle due to image orientation issues in Matlab.
            % -therefore no need to invert (ie. 1-X) circ_r here.
            tempAng = circ_r([fibAng*2*pi/180; boundaryAngle*2*pi/180]);
            tempAng = 180*asin(tempAng)/pi;
            %         %YL debug the NaN angle
            %         if isnan(tempAng)
            %             figure(1002),plot(coords(idx,1),coords(idx,2),'ro','MarkerSize',10)
            %             text(coords(idx,1),coords(idx,2),sprintf('%d',fnum));
            %             disp(sprintf('fiber %d relative angle is Nan, fibAng = %f, boundaryAngle = %f, idx_dist = %d',fnum,fibAng,boundaryAngle,idx))
            % %            pause(3)
            %         end

        end
        relativeAngles.angle2boundaryEdge = tempAng;
    end

    function getRelativeangle2
        % if consider the relative orientaiton, use vector operations
        % objectVector = 20*[cos(objectAngle*pi/180) sin(objectAngle*pi/180) 0];
        % ROIcenterVector = 20*[cos(roiAngle*pi/180) sin(roiAngle*pi/180) 0];
        % u = objectVector;
        % v= ROIcenterVector;
        % relativeAngles.angle2boundaryCenter = atan2d(norm(cross(u,v)),dot(u,v));
        relativeAngles.angle2boundaryCenter = abs(objectAngle -roiAngle);
        %convert to [0 90] degrees
        if relativeAngles.angle2boundaryCenter > 90
            relativeAngles.angle2boundaryCenter = 180 -relativeAngles.angle2boundaryCenter;
        end
    end

    function getRelativeangle3
        % if consider the relative orientaiton, use vector operations
        % centers_lineVector = objectCenter-boundaryCenter;
        % objectVector = 20*[cos(objectAngle*pi/180) sin(objectAngle*pi/180) 0];
        % centers_lineVector = [objectCenter-boundaryCenter 0];
        % u = objectVector;
        % v= centers_lineVector;
        % relativeAngles.angle2centersLine = atan2d(norm(cross(u,v)),dot(u,v));

        % centersLineAngle = atan2d(objectCenter(2)-boundaryCenter(2),objectCenter(1)-boundaryCenter(1));
        centersLineAngle = atand((objectCenter(2)-boundaryCenter(2))/(objectCenter(1)-boundaryCenter(1)));
        % convert to [0 180]degrees
        if centersLineAngle<0
            centersLineAngle = abs(centersLineAngle);
        else
            centersLineAngle = 180- centersLineAngle;
        end
        relativeAngles.angle2centersLine = abs(centersLineAngle-objectAngle);
        % convert to [0 90]
         if relativeAngles.angle2centersLine > 90
            relativeAngles.angle2centersLine = 180-relativeAngles.angle2centersLine;
         end
    
    end
    function showAngles
        fig1 = figure('Name','show angles','Position', [100 300 imWidth imHeight],'NextPlot','replace','NumberTitle','on'); 
        figure(fig1);
        imshow(roiMask)
        ax = gca;
        minCoords = min([coords;objectCenter]);
        maxCoords = max([coords;objectCenter]);
        ax.XLim= [minCoords(2)*0.25 min([maxCoords(2)*2;imWidth])];
        ax.YLim = [minCoords(1)*0.25 min([maxCoords(1)*2; imHeight])];
        pointSize = 5;
        pointColor = 'blue';
        boundaryCenter_point = drawpoint(ax,'Position',boundaryCenter, 'Color',pointColor,'MarkerSize', pointSize);
        objectCenter_point = drawpoint(ax,'Position',objectCenter,'Color',pointColor, 'MarkerSize', pointSize);
        centers_lineVector = objectCenter-boundaryCenter;
        centers_line = drawline(ax,'Position',[boundaryCenter;objectCenter],'Color','r');
        objectVector = 100*[cos(objectAngle*pi/180) -sin(objectAngle*pi/180) 0];
        text(objectCenter(1),objectCenter(2)+10,sprintf('%3.2f',objectAngle),'Color','g')
        drawline("Color",'g','Position',[0+objectCenter(1) 0+objectCenter(2); objectVector(1)+objectCenter(1) objectVector(2)+objectCenter(2)]);
        roiVector  = 100*[cos(roiAngle*pi/180) -sin(roiAngle*pi/180) 0];
        drawline("Color",'m','Position',[boundaryCenter(1),boundaryCenter(2); ...
            roiVector(1)+boundaryCenter(1) roiVector(2)+boundaryCenter(2)]);
        text(boundaryCenter(1),boundaryCenter(2)+10,sprintf('%3.2f',roiAngle),'Color','m');
        text(0.5*(objectCenter(1)+boundaryCenter(1)), 0.5*(objectCenter(2)+boundaryCenter(2)),...
            sprintf('centersline angle: %3.2f',centersLineAngle),'Color','r')
        relativeAngles
    end

end