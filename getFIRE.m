function [object fibKey totLengthList endLengthList curvatureList widthList] = getFIRE(imgName,fireDir,fibProcMeth)

% ctFIRE.m - get the output of the Fire process and convert to something that can be used by CurveAlign
%
% Inputs
%   imgName     name of the image we would like to get the fire output for
%   fireDir     directory where the fire output is located (string)
%   fibProcMeth method by which to process fibers (user selectable)
%                   segments (0): process all fiber segments individually
%                   fibers (1): process each fiber as a single entity
%
% Optional Inputs
%
% Outputs
%   object  structure containing information about each fiber segment position and angle in image
%   fibKey  list containing the index of the beginning of each fiber within object
% 
%
% By Jeremy Bredfeldt and Carolyn Pehlke Laboratory for Optical and
% Computational Instrumentation 2013

%load the fiber list from the fire output mat file (this is generated by the CT-Fire program
dirList = dir(fireDir);
imgNameShort = imgName(1:length(imgName)-4);
for i = 1:length(dirList)
    if ~isempty(regexp(dirList(i).name,imgNameShort,'once')) && ~isempty(regexp(dirList(i).name,'ctFIREout_','once'))
        fibListStruct = load([fireDir dirList(i).name]);
        break;
    end
end

fibStruct = fibListStruct.data; %extract the fiber list structure
LL1 = fibListStruct.cP.LL1; %get the length limit that was used during the CT-FIRE process

%check if struct is empty, if so, return an empty object
if isempty(fibStruct)
    object = [];
    return;
end

num_fib = length(fibStruct.Fai);
X = fibStruct.Xai;


%--Process segments--
totSeg = 0;
if fibProcMeth == 0
    %if processing by segments, loop through all fibers, get the center and angle of each point in each fiber
    %search first to find the number of segments    
    for i = 1:num_fib
        if fibStruct.M.L(i) > LL1
            numSeg = length(fibStruct.Fai(i).v);
            totSeg = totSeg + numSeg;
        end
    end
else
    for i = 1:num_fib
        if fibStruct.M.L(i) > LL1
            totSeg = totSeg + 1;
        end
    end
    if fibProcMeth == 2
        totSeg = 2*totSeg; %one for each endpoint
    end
end
%make objects of the right length
object(totSeg) = struct('center',[],'angle',[],'weight',[]);
fibKey = nan(totSeg,1); %keep track of the segNum at the beginning of each fiber
totLengthList = nan(totSeg,1);
endLengthList = nan(totSeg,1); 
curvatureList = nan(totSeg,1); 
widthList = nan(totSeg,1);

segNum = 0;
fibNum = 0;

for i = 1:num_fib
    fv = fibStruct.Fa(i).v;
    %numSeg = length(fibStruct.M.FangI(i).angle_xy);
    numSeg = length(fv);
    if numSeg > 0 && fibStruct.M.L(i) > LL1
        %get fiber end to end length
        fsp = fibStruct.Fa(i).v(1);
        fep = fibStruct.Fa(i).v(end);
        sp = fibStruct.Xa(fep,:);
        ep = fibStruct.Xa(fsp,:);
        dse = norm(sp-ep); %end to end length of the fiber
        cen = round(mean([sp; ep])); %center point of the fiber
        %get fiber curvature
        fstr = dse/fibStruct.M.L(i);   % fiber straightness
        %get fiber width
        disp([num2str(i) ' of ' num2str(num_fib)]);
        widave = 2*mean(fibStruct.Ra(fv));
        
        fibNum = fibNum + 1;
        
        if fibProcMeth == 0
            %process segments
            for j = 1:numSeg
                segNum = segNum + 1;              
                fibKey(segNum) = i;
                v1 = fv(j);
                x1 = X(v1,:);
                pt1 = [x1(2) x1(1)];
                %get the center of the segment
                object(segNum).center = round(pt1);                
                %set angle to be that of the current segment
                theta = -1*fibStruct.M.FangI(i).angle_xy(j); %neg is to make angle match boundary file
                thetaDeg = theta*180/pi;
                if thetaDeg < 0
                    thetaDeg = thetaDeg + 180;
                end
                object(segNum).angle = thetaDeg;

                totLengthList(segNum) = fibStruct.M.L(i);
                endLengthList(segNum) = dse; 
                curvatureList(segNum) = fstr; 
                widthList(segNum) = widave;            
            end
        else
            %process fibers or end points
            %write out fiber angle
            theta = -1*fibStruct.M.angle_xy(i); %neg is to make angle match boundary file
            thetaDeg = theta*180/pi;
            if thetaDeg < 0
                thetaDeg = thetaDeg + 180;
            end            
            object(fibNum).angle = thetaDeg;            
            totLengthList(fibNum) = fibStruct.M.L(i);
            endLengthList(fibNum) = dse; 
            curvatureList(fibNum) = fstr; 
            widthList(fibNum) = widave; 
            
            %write out fiber position
            if fibProcMeth == 1
                object(fibNum).center = [cen(2) cen(1)];
            elseif fibProcMeth == 2
                totSeg2 = totSeg/2;
                object(fibNum).center = round([sp(2) sp(1)]);
                object(fibNum+totSeg2).center = round([ep(2) ep(1)]);
                object(fibNum+totSeg2).angle = thetaDeg;            
                totLengthList(fibNum+totSeg2) = fibStruct.M.L(i);
                endLengthList(fibNum+totSeg2) = dse; 
                curvatureList(fibNum+totSeg2) = fstr; 
                widthList(fibNum+totSeg2) = widave;                
            end
        end
    end
end

%filter the fiber angles and add weight
fSize = round(64);
fSize2 = ceil(fSize/2); 
c = vertcat(object.center);
x = c(:,1);
y = c(:,2);
for i = 1:length(object)
    %alignment filter, we want high alignment areas to have a higher
    %weight       
        
    %find any positions that are in a square region around the
    %current fiber
    ind2 = x > x(i)-fSize2 & x < x(i)+fSize2 & y > y(i)-fSize2 & y < y(i)+fSize2;
    %get all the fibers in that area
    vals = vertcat(object(ind2).angle);
    if length(vals) > 1 && length(vals) < 5 %filter out high fiber density here, hi den = low tacs3
        %Perform the circular angle uniformity test, first scale values from 0-180 deg to 0-2*pi (orientation!)        
        object(i).weight = (circ_r(vals*2*pi/180))*length(vals);        
    elseif length(vals) == 1
        object(i).weight = 1;
    else
        object(i).weight = 0;
end

end